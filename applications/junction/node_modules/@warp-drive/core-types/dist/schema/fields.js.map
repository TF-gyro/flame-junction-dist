{"version":3,"file":"fields.js","sources":["../../src/schema/fields.ts"],"sourcesContent":["/**\n * @module @warp-drive/core-types\n */\nimport type { ObjectValue, PrimitiveValue } from '../json/raw';\n\n/**\n * A generic \"field\" that can be used to define\n * primitive value fields.\n *\n * Replaces \"attribute\" for primitive value fields.\n * Can also be used to eject from deep-tracking of\n * objects or arrays.\n *\n * A major difference between \"field\" and \"attribute\"\n * is that \"type\" points to a legacy transform on\n * \"attribute\" that a serializer *might* use, while\n * \"type\" points to a new-style transform on \"field\"\n * that a record implmentation *must* use.\n *\n * @typedoc\n */\nexport interface GenericField {\n  kind: 'field';\n  name: string;\n  /**\n   * the name of the transform to use, if any\n   * @typedoc\n   */\n  type?: string;\n  /**\n   * Options to pass to the transform, if any\n   *\n   * Must comply to the specific transform's options\n   * schema.\n   *\n   * @typedoc\n   */\n  options?: ObjectValue;\n}\n\n/**\n * A field that can be used to alias one key to another\n * key present in the cache version of the resource.\n *\n * Unlike DerivedField, an AliasField may write to its\n * source when a record is in an editable mode.\n *\n * AliasFields may utilize a transform, specified by type,\n * to pre/post process the field.\n *\n * An AliasField may also specify a `kind` via options.\n * `kind` may be any other valid field kind other than\n *\n * - `@hash`\n * - `@id`\n * - `@local`\n * - `derived`\n *\n * This allows an AliasField to rename any field in the cache.\n *\n * Alias fields are generally intended to be used to support migrating\n * between different schemas, though there are times where they are useful\n * as a form of advanced derivation when used with a transform. For instance,\n * an AliasField could be used to expose both a string and a Date version of the\n * same field, with both being capable of being written to.\n *\n * @typedoc\n */\nexport interface LegacyAliasField {\n  kind: 'alias';\n  name: string;\n  type: null; // should always be null\n\n  /**\n   * The field def for which this is an alias.\n   *\n   * @typedoc\n   */\n  options:\n    | GenericField\n    | ObjectField\n    | SchemaObjectField\n    | ArrayField\n    | SchemaArrayField\n    // | ResourceField\n    // | CollectionField\n    | LegacyAttributeField\n    | LegacyBelongsToField\n    | LegacyHasManyField;\n}\n\n/**\n * A field that can be used to alias one key to another\n * key present in the cache version of the resource.\n *\n * Unlike DerivedField, an AliasField may write to its\n * source when a record is in an editable mode.\n *\n * AliasFields may utilize a transform, specified by type,\n * to pre/post process the field.\n *\n * An AliasField may also specify a `kind` via options.\n * `kind` may be any other valid field kind other than\n *\n * - `@hash`\n * - `@id`\n * - `@local`\n * - `derived`\n *\n * This allows an AliasField to rename any field in the cache.\n *\n * Alias fields are generally intended to be used to support migrating\n * between different schemas, though there are times where they are useful\n * as a form of advanced derivation when used with a transform. For instance,\n * an AliasField could be used to expose both a string and a Date version of the\n * same field, with both being capable of being written to.\n *\n * @typedoc\n */\nexport interface PolarisAliasField {\n  kind: 'alias';\n  name: string;\n  type: null; // should always be null\n\n  /**\n   * The field def for which this is an alias.\n   *\n   * @typedoc\n   */\n  options:\n    | GenericField\n    | ObjectField\n    | SchemaObjectField\n    | ArrayField\n    | SchemaArrayField\n    // | ResourceField\n    // | CollectionField\n    | LinksModeBelongsToField\n    | LinksModeHasManyField;\n}\n\n/**\n * A field that can be used to alias one key to another\n * key present in the cache version of the resource.\n *\n * Unlike DerivedField, an AliasField may write to its\n * source when a record is in an editable mode.\n *\n * AliasFields may utilize a transform, specified by type,\n * to pre/post process the field.\n *\n * An AliasField may also specify a `kind` via options.\n * `kind` may be any other valid field kind other than\n *\n * - `@hash`\n * - `@id`\n * - `@local`\n * - `derived`\n *\n * This allows an AliasField to rename any field in the cache.\n *\n * Alias fields are generally intended to be used to support migrating\n * between different schemas, though there are times where they are useful\n * as a form of advanced derivation when used with a transform. For instance,\n * an AliasField could be used to expose both a string and a Date version of the\n * same field, with both being capable of being written to.\n *\n * @typedoc\n */\nexport interface ObjectAliasField {\n  kind: 'alias';\n  name: string;\n  type: null; // should always be null\n\n  /**\n   * The field def for which this is an alias.\n   *\n   * @typedoc\n   */\n  options: GenericField | ObjectField | SchemaObjectField | ArrayField | SchemaArrayField;\n}\n\n/**\n * Represents a field whose value is the primary\n * key of the resource.\n *\n * This allows any field to serve as the primary\n * key while still being able to drive identity\n * needs within the system.\n *\n * This is useful for resources that use for instance\n * 'uuid', 'urn' or 'entityUrn' or 'primaryKey' as their\n * primary key field instead of 'id'.\n *\n * @typedoc\n */\nexport interface IdentityField {\n  kind: '@id';\n\n  /**\n   * The name of the field that serves as the\n   * primary key for the resource.\n   *\n   * @typedoc\n   */\n  name: string;\n}\n\n/**\n * Represents a specialized field whose computed value\n * will be used as the primary key of a schema-object\n * for serializability and comparison purposes.\n *\n * This field functions similarly to derived fields in that\n * it is non-settable, derived state but differs in that\n * it is only able to compute off of cache state and is given\n * no access to a record instance.\n *\n * This means that if a hashing function wants to compute its value\n * taking into account transformations and derivations it must\n * perform those itself.\n *\n * A schema-array can declare its \"key\" value to be `@hash` if\n * a schema-object has such a field.\n *\n * Only one hash field is permittable per schema-object, and\n * it should be placed in the `ResourceSchema`'s `@id` field\n * in place of an `IdentityField`.\n *\n * @typedoc\n */\nexport interface HashField {\n  kind: '@hash';\n\n  /**\n   * The name of the field that serves as the\n   * hash for the resource.\n   *\n   * Only required if access to this value by\n   * the UI is desired, it can be `null` otherwise.\n   *\n   * @typedoc\n   */\n  name: string | null;\n\n  /**\n   * The name of a function to run to compute the hash.\n   * The function will only have access to the cached\n   * data for the record.\n   *\n   * @typedoc\n   */\n  type: string;\n\n  /**\n   * Any options that should be provided to the hash\n   * function.\n   *\n   * @typedoc\n   */\n  options?: ObjectValue;\n}\n\n/**\n * Represents a field whose value is a local\n * value that is not stored in the cache, nor\n * is it sent to the server.\n *\n * Local fields can be written to, and their\n * value is both memoized and reactive (though\n * not deep-tracked).\n *\n * Because their state is not derived from the cache\n * data or the server, they represent a divorced\n * uncanonical source of state.\n *\n * For this reason Local fields should be used sparingly.\n *\n * Currently, while we document this feature here,\n * only allow our own SchemaRecord should utilize them\n * and the feature should be considered private.\n *\n * Example use cases that drove the creation of local\n * fields are states like `isDestroying` and `isDestroyed`\n * which are specific to a record instance but not\n * stored in the cache. We wanted to be able to drive\n * these fields from schema the same as all other fields.\n *\n * Don't make us regret this decision.\n *\n * @typedoc\n */\nexport interface LocalField {\n  kind: '@local';\n  name: string;\n  /**\n   * Not currently utilized, we are considering\n   * allowing transforms to operate on local fields\n   *\n   * @typedoc\n   */\n  type?: string;\n  options?: { defaultValue?: PrimitiveValue };\n}\n\n/**\n * Represents a field whose value is an object\n * with keys pointing to values that are primitive\n * values.\n *\n * If values of the keys are not primitives, or\n * if the key/value pairs have well-defined shape,\n * use 'schema-object' instead.\n *\n * @typedoc\n */\nexport interface ObjectField {\n  kind: 'object';\n  name: string;\n\n  /**\n   * The name of a transform to pass the entire object\n   * through before displaying or serializing it.\n   *\n   * @typedoc\n   */\n  type?: string;\n\n  /**\n   * Options to pass to the transform, if any\n   *\n   * Must comply to the specific transform's options\n   * schema.\n   *\n   * @typedoc\n   */\n  options?: ObjectValue;\n}\n\n/**\n * Represents a field whose value is an object\n * with a well-defined structure described by\n * a non-resource schema.\n *\n * If the object's structure is not well-defined,\n * use 'object' instead.\n *\n * @typedoc\n */\nexport interface SchemaObjectField {\n  kind: 'schema-object';\n  name: string;\n\n  /**\n   * The name of the schema that describes the\n   * structure of the object.\n   *\n   * These schemas\n   *\n   * @typedoc\n   */\n  type: string;\n\n  options?: {\n    /**\n     * Whether this SchemaObject is Polymorphic.\n     *\n     * If the SchemaObject is polymorphic, `options.type` must also be supplied.\n     *\n     * @typedoc\n     */\n    polymorphic?: boolean;\n\n    /**\n     * If the SchemaObject is Polymorphic, the key on the raw cache data to use\n     * as the \"resource-type\" value for the schema-object.\n     *\n     * Defaults to \"type\".\n     *\n     * @typedoc\n     */\n    type?: string;\n  };\n}\n\n/**\n * Represents a field whose value is an array\n * of primitive values.\n *\n * If the array's elements are not primitive\n * values, use 'schema-array' instead.\n *\n * @typedoc\n */\nexport interface ArrayField {\n  kind: 'array';\n  name: string;\n\n  /**\n   * The name of a transform to pass each item\n   * in the array through before displaying or\n   * or serializing it.\n   *\n   * @typedoc\n   */\n  type?: string;\n\n  /**\n   * Options to pass to the transform, if any\n   *\n   * Must comply to the specific transform's options\n   * schema.\n   *\n   * @typedoc\n   */\n  options?: ObjectValue;\n}\n\n/**\n * Represents a field whose value is an array\n * of objects with a well-defined structure\n * described by a non-resource schema.\n *\n * If the array's elements are not well-defined,\n * use 'array' instead.\n *\n * @typedoc\n */\nexport interface SchemaArrayField {\n  kind: 'schema-array';\n  name: string;\n\n  /**\n   * The name of the schema that describes the\n   * structure of the objects in the array.\n   *\n   * @typedoc\n   */\n  type: string;\n\n  /**\n   * Options for configuring the behavior of the\n   * SchemaArray.\n   *\n   * @typedoc\n   */\n\n  /**\n   * Options for configuring the behavior of the\n   * SchemaArray.\n   *\n   * @typedoc\n   */\n  options?: {\n    /**\n     * Configures how the SchemaArray determines whether\n     * an object in the cache is the same as an object\n     * previously used to instantiate one of the schema-objects\n     * it contains.\n     *\n     * The default is `'@identity'`.\n     *\n     * Valid options are:\n     *\n     * - `'@identity'` (default) : the cached object's referential identity will be used.\n     *       This may result in significant instability when resource data is updated from the API\n     * - `'@index'`              : the cached object's index in the array will be used.\n     *       This is only a good choice for arrays that rarely if ever change membership\n     * - `'@hash'`               : will lookup the `@hash` function supplied in the ResourceSchema for\n     *       The contained schema-object and use the computed result to determine and compare identity.\n     * - <field-name> (string)   : the name of a field to use as the key, only GenericFields (kind `field`)\n     *       Are valid field names for this purpose. The cache state without transforms applied will be\n     *       used when comparing values. The field value should be unique enough to guarantee two schema-objects\n     *       of the same type will not collide.\n     *\n     * @typedoc\n     */\n    key?: '@identity' | '@index' | '@hash' | string;\n\n    /**\n     * Whether this SchemaArray is Polymorphic.\n     *\n     * If the SchemaArray is polymorphic, `options.type` must also be supplied.\n     *\n     * @typedoc\n     */\n    polymorphic?: boolean;\n\n    /**\n     * If the SchemaArray is Polymorphic, the key on the raw cache data to use\n     * as the \"resource-type\" value for the schema-object.\n     *\n     * Defaults to \"type\".\n     *\n     * @typedoc\n     */\n    type?: string;\n  };\n}\n\n/**\n * Represents a field whose value is derived\n * from other fields in the schema.\n *\n * The value is read-only, and is not stored\n * in the cache, nor is it sent to the server.\n *\n * Usage of derived fields should be minimized\n * to scenarios where the derivation is known\n * to be safe. For instance, derivations that\n * required fields that are not always loaded\n * or that require access to related resources\n * that may not be loaded should be avoided.\n *\n * @typedoc\n */\nexport interface DerivedField {\n  kind: 'derived';\n  name: string;\n\n  /**\n   * The name of the derivation to use.\n   *\n   * Derivations are functions that take the\n   * record, options, and the name of the field\n   * as arguments, and return the derived value.\n   *\n   * Derivations are memoized, and are only\n   * recomputed when the fields they depend on\n   * change.\n   *\n   * Derivations are not stored in the cache,\n   * and are not sent to the server.\n   *\n   * Derivation functions must be explicitly\n   * registered with the schema service.\n   *\n   * @typedoc\n   */\n  type: string;\n\n  /**\n   * Options to pass to the derivation, if any\n   *\n   * Must comply to the specific derivation's\n   * options schema.\n   *\n   * @typedoc\n   */\n  options?: ObjectValue;\n}\n\n/**\n * Represents a field that is a reference to\n * another resource.\n *\n * SUPPORT FOR THIS FEATURE IS NOT YET IMPLEMENTED\n * BY SchemaRecord\n *\n * @typedoc\n */\nexport interface ResourceField {\n  kind: 'resource';\n  name: string;\n\n  /**\n   * The name of the resource that this field\n   * refers to. In the case of a polymorphic\n   * relationship, this should be the trait\n   * or abstract type.\n   *\n   * @typedoc\n   */\n  type: string;\n\n  /**\n   * Options for resources are optional. If\n   * not present, all options are presumed\n   * to be falsey\n   *\n   * @typedoc\n   */\n  options?: {\n    /**\n     * Whether the relationship is async\n     *\n     * If true, it is expected that the cache\n     * data for this field will contain a link\n     * that can be used to fetch the related\n     * resource when needed.\n     *\n     * @typedoc\n     */\n    async?: boolean;\n\n    /**\n     * The name of the inverse field on the\n     * related resource that points back to\n     * this field on this resource to form a\n     * bidirectional relationship.\n     *\n     * If null, the relationship is unidirectional.\n     *\n     * @typedoc\n     */\n    inverse?: string | null;\n\n    /**\n     * If this field is satisfying a polymorphic\n     * relationship on another resource, then this\n     * should be set to the trait or abstract type\n     * that this resource implements.\n     *\n     * @typedoc\n     */\n    as?: string;\n\n    /**\n     * Whether this field is a polymorphic relationship,\n     * meaning that it can point to multiple types of\n     * resources so long as they implement the trait\n     * or abstract type specified in `type`.\n     *\n     * @typedoc\n     */\n    polymorphic?: boolean;\n  };\n}\n\n/**\n * Represents a field that is a reference to\n * a collection of other resources, potentially\n * paginate.\n *\n * SUPPORT FOR THIS FEATURE IS NOT YET IMPLEMENTED\n * BY SchemaRecord\n *\n * @typedoc\n */\nexport interface CollectionField {\n  kind: 'collection';\n  name: string;\n\n  /**\n   * The name of the resource that this field\n   * refers to. In the case of a polymorphic\n   * relationship, this should be the trait\n   * or abstract type.\n   *\n   * @typedoc\n   */\n  type: string;\n\n  /**\n   * Options for resources are optional. If\n   * not present, all options are presumed\n   * to be falsey\n   *\n   * @typedoc\n   */\n  options?: {\n    /**\n     * Whether the relationship is async\n     *\n     * If true, it is expected that the cache\n     * data for this field will contain links\n     * that can be used to fetch the related\n     * resources when needed.\n     *\n     * When false, it is expected that all related\n     * resources are loaded together with this resource,\n     * and that the cache data for this field will\n     * contain the full list of pointers.\n     *\n     * When true, it is expected that the relationship\n     * is paginated. If the relationship is not paginated,\n     * then the cache data for \"page 1\" would contain the\n     * full list of pointers, and loading \"page 1\" would\n     * load all related resources.\n     *\n     * @typedoc\n     */\n    async?: boolean;\n\n    /**\n     * The name of the inverse field on the\n     * related resource that points back to\n     * this field on this resource to form a\n     * bidirectional relationship.\n     *\n     * If null, the relationship is unidirectional.\n     *\n     * @typedoc\n     */\n    inverse?: string | null;\n\n    /**\n     * If this field is satisfying a polymorphic\n     * relationship on another resource, then this\n     * should be set to the trait or abstract type\n     * that this resource implements.\n     *\n     * @typedoc\n     */\n    as?: string;\n\n    /**\n     * Whether this field is a polymorphic relationship,\n     * meaning that it can point to multiple types of\n     * resources so long as they implement the trait\n     * or abstract type specified in `type`.\n     *\n     * @typedoc\n     */\n    polymorphic?: boolean;\n  };\n}\n\n/**\n * > [!CAUTION]\n * > This Field is LEGACY\n * > It cannot be used with PolarisMode\n *\n * A generic \"field\" that can be used to define\n * primitive value fields.\n *\n * If the field points to an object or array,\n * it will not be deep-tracked.\n *\n * Transforms when defined are legacy transforms\n * that a serializer *might* use, but their usage\n * is not guaranteed.\n *\n * @typedoc\n */\nexport interface LegacyAttributeField {\n  kind: 'attribute';\n  name: string;\n  /**\n   * The name of the transform to use, if any\n   *\n   * @typedoc\n   */\n  type?: string | null;\n  /**\n   * Options to pass to the transform, if any\n   *\n   * Must comply to the specific transform's options\n   * schema.\n   *\n   * @typedoc\n   */\n  options?: ObjectValue;\n}\n\n/**\n * > [!CAUTION]\n * > This Field is LEGACY\n *\n * Represents a field that is a reference to\n * another resource.\n *\n * This is the legacy version of the `ResourceField`.\n *\n * @typedoc\n */\nexport interface LegacyBelongsToField {\n  kind: 'belongsTo';\n  name: string;\n\n  /**\n   * The name of the resource that this field\n   * refers to. In the case of a polymorphic\n   * relationship, this should be the trait\n   * or abstract type.\n   *\n   * @typedoc\n   */\n  type: string;\n\n  /**\n   * Options for belongsTo are mandatory.\n   *\n   * @typedoc\n   */\n  options: {\n    /**\n     * Whether the relationship is async\n     *\n     * If true, it is expected that the cache\n     * data for this field will contain a link\n     * or a pointer that can be used to fetch\n     * the related resource when needed.\n     *\n     * Pointers are highly discouraged.\n     *\n     * @typedoc\n     */\n    async: boolean;\n\n    /**\n     * The name of the inverse field on the\n     * related resource that points back to\n     * this field on this resource to form a\n     * bidirectional relationship.\n     *\n     * If null, the relationship is unidirectional.\n     *\n     * @typedoc\n     */\n    inverse: string | null;\n\n    /**\n     * If this field is satisfying a polymorphic\n     * relationship on another resource, then this\n     * should be set to the trait or abstract type\n     * that this resource implements.\n     *\n     * @typedoc\n     */\n    as?: string;\n\n    /**\n     * Whether this field is a polymorphic relationship,\n     * meaning that it can point to multiple types of\n     * resources so long as they implement the trait\n     * or abstract type specified in `type`.\n     *\n     * @typedoc\n     */\n    polymorphic?: boolean;\n\n    /**\n     * Whether this field should ever make use of the legacy support infra\n     * from @ember-data/model and the LegacyNetworkMiddleware for adapters and serializers.\n     *\n     * When true, none of the legacy support will be utilized. Sync relationships\n     * will be expected to already have all their data. When reloading a sync relationship\n     * you would be expected to have a `related link` available from a prior relationship\n     * payload e.g.\n     *\n     * ```ts\n     * {\n     *   data: {\n     *     type: 'user',\n     *     id: '2',\n     *     attributes: { name: 'Chris' },\n     *     relationships: {\n     *       bestFriend: {\n     *         links: { related: \"/users/1/bestFriend\" },\n     *         data: { type: 'user', id: '1' },\n     *       }\n     *     }\n     *   },\n     *   included: [\n     *     { type: 'user', id: '1', attributes: { name: 'Krystan' } }\n     *   ]\n     * }\n     * ```\n     *\n     * Async relationships will be loaded via their link if needed.\n     *\n     * @typedoc\n     */\n    linksMode?: true;\n\n    /**\n     * When omitted, the cache data for this field will\n     * clear local state of all changes except for the\n     * addition of records still in the \"new\" state any\n     * time the remote data for this field is updated.\n     *\n     * When set to `false`, the cache data for this field\n     * will instead intelligently commit any changes from\n     * local state that are present in the remote data,\n     * leaving any remaining changes in local state still.\n     *\n     * @typedoc\n     */\n    resetOnRemoteUpdate?: false;\n  };\n}\n\n/**\n * > [!CAUTION]\n * > This Field is LEGACY\n *\n * Represents a field that is a reference to\n * another resource.\n *\n * This is the legacy version of the `ResourceField`.\n *\n * @typedoc\n */\nexport interface LinksModeBelongsToField {\n  kind: 'belongsTo';\n  name: string;\n\n  /**\n   * The name of the resource that this field\n   * refers to. In the case of a polymorphic\n   * relationship, this should be the trait\n   * or abstract type.\n   *\n   * @typedoc\n   */\n  type: string;\n\n  /**\n   * Options for belongsTo are mandatory.\n   *\n   * @typedoc\n   */\n  options: {\n    /**\n     * Whether the relationship is async\n     *\n     * MUST be false for PolarisMode + LinksMode\n     *\n     * @typedoc\n     */\n    async: false;\n\n    /**\n     * The name of the inverse field on the\n     * related resource that points back to\n     * this field on this resource to form a\n     * bidirectional relationship.\n     *\n     * If null, the relationship is unidirectional.\n     *\n     * @typedoc\n     */\n    inverse: string | null;\n\n    /**\n     * If this field is satisfying a polymorphic\n     * relationship on another resource, then this\n     * should be set to the trait or abstract type\n     * that this resource implements.\n     *\n     * @typedoc\n     */\n    as?: string;\n\n    /**\n     * Whether this field is a polymorphic relationship,\n     * meaning that it can point to multiple types of\n     * resources so long as they implement the trait\n     * or abstract type specified in `type`.\n     *\n     * @typedoc\n     */\n    polymorphic?: boolean;\n\n    /**\n     * Whether this field should ever make use of the legacy support infra\n     * from @ember-data/model and the LegacyNetworkMiddleware for adapters and serializers.\n     *\n     * MUST be true for PolarisMode + LinksMode\n     *\n     * When true, none of the legacy support will be utilized. Sync relationships\n     * will be expected to already have all their data. When reloading a sync relationship\n     * you would be expected to have a `related link` available from a prior relationship\n     * payload e.g.\n     *\n     * ```ts\n     * {\n     *   data: {\n     *     type: 'user',\n     *     id: '2',\n     *     attributes: { name: 'Chris' },\n     *     relationships: {\n     *       bestFriend: {\n     *         links: { related: \"/users/1/bestFriend\" },\n     *         data: { type: 'user', id: '1' },\n     *       }\n     *     }\n     *   },\n     *   included: [\n     *     { type: 'user', id: '1', attributes: { name: 'Krystan' } }\n     *   ]\n     * }\n     * ```\n     *\n     * Async relationships will be loaded via their link if needed.\n     *\n     * @typedoc\n     */\n    linksMode: true;\n\n    /**\n     * When omitted, the cache data for this field will\n     * clear local state of all changes except for the\n     * addition of records still in the \"new\" state any\n     * time the remote data for this field is updated.\n     *\n     * When set to `false`, the cache data for this field\n     * will instead intelligently commit any changes from\n     * local state that are present in the remote data,\n     * leaving any remaining changes in local state still.\n     *\n     * MUST be false for PolarisMode + LinksMode\n     *\n     * @typedoc\n     */\n    resetOnRemoteUpdate: false;\n  };\n}\n\n/**\n * > [!CAUTION]\n * > This Field is LEGACY\n *\n * Represents a field that is a reference to\n * a collection of other resources.\n *\n * This is the legacy version of the `CollectionField`.\n *\n * @typedoc\n */\nexport interface LegacyHasManyField {\n  kind: 'hasMany';\n  name: string;\n  type: string;\n\n  /**\n   * Options for hasMany are mandatory.\n   *\n   * @typedoc\n   */\n  options: {\n    /**\n     * Whether the relationship is async\n     *\n     * If true, it is expected that the cache\n     * data for this field will contain links\n     * or pointers that can be used to fetch\n     * the related resources when needed.\n     *\n     * When false, it is expected that all related\n     * resources are loaded together with this resource,\n     * and that the cache data for this field will\n     * contain the full list of pointers.\n     *\n     * hasMany relationships do not support pagination.\n     *\n     * @typedoc\n     */\n    async: boolean;\n\n    /**\n     * The name of the inverse field on the\n     * related resource that points back to\n     * this field on this resource to form a\n     * bidirectional relationship.\n     *\n     * If null, the relationship is unidirectional.\n     *\n     * @typedoc\n     */\n    inverse: string | null;\n\n    /**\n     * If this field is satisfying a polymorphic\n     * relationship on another resource, then this\n     * should be set to the trait or abstract type\n     * that this resource implements.\n     *\n     * @typedoc\n     */\n    as?: string;\n\n    /**\n     * Whether this field is a polymorphic relationship,\n     * meaning that it can point to multiple types of\n     * resources so long as they implement the trait\n     * or abstract type specified in `type`.\n     *\n     * @typedoc\n     */\n    polymorphic?: boolean;\n\n    /**\n     * Whether this field should ever make use of the legacy support infra\n     * from @ember-data/model and the LegacyNetworkMiddleware for adapters and serializers.\n     *\n     * When true, none of the legacy support will be utilized. Sync relationships\n     * will be expected to already have all their data. When reloading a sync relationship\n     * you would be expected to have a `related link` available from a prior relationship\n     * payload e.g.\n     *\n     * ```ts\n     * {\n     *   data: {\n     *     type: 'user',\n     *     id: '2',\n     *     attributes: { name: 'Chris' },\n     *     relationships: {\n     *       bestFriends: {\n     *         links: { related: \"/users/1/bestFriends\" },\n     *         data: [ { type: 'user', id: '1' } ],\n     *       }\n     *     }\n     *   },\n     *   included: [\n     *     { type: 'user', id: '1', attributes: { name: 'Krystan' } }\n     *   ]\n     * }\n     * ```\n     *\n     * Async relationships will be loaded via their link if needed.\n     *\n     * @typedoc\n     */\n    linksMode?: true;\n\n    /**\n     * When omitted, the cache data for this field will\n     * clear local state of all changes except for the\n     * addition of records still in the \"new\" state any\n     * time the remote data for this field is updated.\n     *\n     * When set to `false`, the cache data for this field\n     * will instead intelligently commit any changes from\n     * local state that are present in the remote data,\n     * leaving any remaining changes in local state still.\n     *\n     * @typedoc\n     */\n    resetOnRemoteUpdate?: false;\n  };\n}\n\n/**\n * > [!CAUTION]\n * > This Field is LEGACY\n *\n * Represents a field that is a reference to\n * a collection of other resources.\n *\n * This is the legacy version of the `CollectionField`.\n *\n * @typedoc\n */\nexport interface LinksModeHasManyField {\n  kind: 'hasMany';\n  name: string;\n  type: string;\n\n  /**\n   * Options for hasMany are mandatory.\n   *\n   * @typedoc\n   */\n  options: {\n    /**\n     * Whether the relationship is async\n     *\n     * MUST be false for PolarisMode + LinksMode\n     *\n     * If true, it is expected that the cache\n     * data for this field will contain links\n     * or pointers that can be used to fetch\n     * the related resources when needed.\n     *\n     * When false, it is expected that all related\n     * resources are loaded together with this resource,\n     * and that the cache data for this field will\n     * contain the full list of pointers.\n     *\n     * hasMany relationships do not support pagination.\n     *\n     * @typedoc\n     */\n    async: false;\n\n    /**\n     * The name of the inverse field on the\n     * related resource that points back to\n     * this field on this resource to form a\n     * bidirectional relationship.\n     *\n     * If null, the relationship is unidirectional.\n     *\n     * @typedoc\n     */\n    inverse: string | null;\n\n    /**\n     * If this field is satisfying a polymorphic\n     * relationship on another resource, then this\n     * should be set to the trait or abstract type\n     * that this resource implements.\n     *\n     * @typedoc\n     */\n    as?: string;\n\n    /**\n     * Whether this field is a polymorphic relationship,\n     * meaning that it can point to multiple types of\n     * resources so long as they implement the trait\n     * or abstract type specified in `type`.\n     *\n     * @typedoc\n     */\n    polymorphic?: boolean;\n\n    /**\n     * Whether this field should ever make use of the legacy support infra\n     * from @ember-data/model and the LegacyNetworkMiddleware for adapters and serializers.\n     *\n     * MUST be true for PolarisMode + LinksMode\n     *\n     * When true, none of the legacy support will be utilized. Sync relationships\n     * will be expected to already have all their data. When reloading a sync relationship\n     * you would be expected to have a `related link` available from a prior relationship\n     * payload e.g.\n     *\n     * ```ts\n     * {\n     *   data: {\n     *     type: 'user',\n     *     id: '2',\n     *     attributes: { name: 'Chris' },\n     *     relationships: {\n     *       bestFriends: {\n     *         links: { related: \"/users/1/bestFriends\" },\n     *         data: [ { type: 'user', id: '1' } ],\n     *       }\n     *     }\n     *   },\n     *   included: [\n     *     { type: 'user', id: '1', attributes: { name: 'Krystan' } }\n     *   ]\n     * }\n     * ```\n     *\n     * Async relationships will be loaded via their link if needed.\n     *\n     * @typedoc\n     */\n    linksMode: true;\n\n    /**\n     * When omitted, the cache data for this field will\n     * clear local state of all changes except for the\n     * addition of records still in the \"new\" state any\n     * time the remote data for this field is updated.\n     *\n     * When set to `false`, the cache data for this field\n     * will instead intelligently commit any changes from\n     * local state that are present in the remote data,\n     * leaving any remaining changes in local state still.\n     *\n     * MUST be false for PolarisMode + LinksMode\n     *\n     * @typedoc\n     */\n    resetOnRemoteUpdate: false;\n  };\n}\n\n/**\n * A union of all possible LegacyMode field schemas.\n *\n * @typedoc\n */\nexport type LegacyModeFieldSchema =\n  | GenericField\n  | LegacyAliasField\n  | LocalField\n  | ObjectField\n  | SchemaObjectField\n  | ArrayField\n  | SchemaArrayField\n  | DerivedField\n  //  | ResourceField\n  //  | CollectionField\n  | LegacyAttributeField\n  | LegacyBelongsToField\n  | LegacyHasManyField;\n\n/**\n * A union of all possible PolarisMode field schemas.\n *\n * @typedoc\n */\nexport type PolarisModeFieldSchema =\n  | GenericField\n  | PolarisAliasField\n  | LocalField\n  | ObjectField\n  | SchemaObjectField\n  | ArrayField\n  | SchemaArrayField\n  | DerivedField\n  //  | ResourceField\n  //  | CollectionField\n  | LinksModeBelongsToField\n  | LinksModeHasManyField;\n\n/**\n * A union of all possible LegacyMode and PolarisMode\n * field schemas.\n *\n * You likely will want to use PolarisModeFieldSchema,\n * LegacyModeFieldSchema, or ObjectFieldSchema instead\n * as appropriate as they are more specific and will\n * provide better guidance around what is valid.\n *\n * @typedoc\n */\nexport type FieldSchema =\n  | GenericField\n  | LegacyAliasField\n  | PolarisAliasField\n  | LocalField\n  | ObjectField\n  | SchemaObjectField\n  | ArrayField\n  | SchemaArrayField\n  | DerivedField\n  | ResourceField\n  | CollectionField\n  | LegacyAttributeField\n  | LegacyBelongsToField\n  | LegacyHasManyField\n  | LinksModeBelongsToField\n  | LinksModeHasManyField;\n\n/**\n * A union of all possible field schemas that can be\n * used in an ObjectSchema.\n *\n * @typedoc\n */\nexport type ObjectFieldSchema =\n  | GenericField\n  | ObjectAliasField\n  | LocalField\n  | ObjectField\n  | SchemaObjectField\n  | ArrayField\n  | SchemaArrayField\n  | DerivedField;\n\n/**\n * Represents a schema for a primary resource in PolarisMode.\n *\n * Primary resources are objects with a unique identity of their\n * own which may allow them to appear in relationships, or in multiple\n * response documents.\n *\n * @typedoc\n */\nexport interface PolarisResourceSchema {\n  legacy?: false;\n\n  /**\n   * For primary resources, this should be an IdentityField\n   *\n   * for schema-objects, this should be either a HashField or null\n   *\n   * @typedoc\n   */\n  identity: IdentityField;\n\n  /**\n   * The name of the schema\n   *\n   * For cacheable resources, this should be the\n   * primary resource type.\n   *\n   * For object schemas, this should be the name\n   * of the object schema.\n   *\n   * The names of object and resource schemas share\n   * a single namespace and must not conflict.\n   *\n   * We recommend a naming convention for object schemas\n   * such as below for ensuring uniqueness:\n   *\n   * - for globally shared objects: The pattern `$field:${KlassName}` e.g. `$field:AddressObject`\n   * - for resource-specific objects: The pattern `$${ResourceKlassName}:$field:${KlassName}` e.g. `$User:$field:ReusableAddress`\n   * - for inline objects: The pattern `$${ResourceKlassName}.${fieldPath}:$field:anonymous` e.g. `$User.shippingAddress:$field:anonymous`\n   *\n   * @typedoc\n   */\n  type: string;\n\n  /**\n   * The fields that make up the shape of the resource\n   *\n   * @typedoc\n   */\n  fields: PolarisModeFieldSchema[];\n\n  /**\n   * A list of traits that this resource implements. The fields for these\n   * traits should still be defined in the fields array.\n   *\n   * Each trait should be a string that matches the `type` of another\n   * resource schema. The trait can be abstract and reference a resource\n   * type that is never defined as a schema.\n   *\n   * @typedoc\n   */\n  traits?: string[];\n}\n\n/**\n * Represents a schema for a primary resource in LegacyMode\n *\n * Primary resources are objects with a unique identity of their\n * own which may allow them to appear in relationships, or in multiple\n * response documents.\n *\n * @typedoc\n */\nexport interface LegacyResourceSchema {\n  legacy: true;\n\n  /**\n   * For primary resources, this should be an IdentityField\n   *\n   * for schema-objects, this should be either a HashField or null\n   *\n   * @typedoc\n   */\n  identity: IdentityField;\n\n  /**\n   * The name of the schema\n   *\n   * For cacheable resources, this should be the\n   * primary resource type.\n   *\n   * For object schemas, this should be the name\n   * of the object schema.\n   *\n   * The names of object and resource schemas share\n   * a single namespace and must not conflict.\n   *\n   * We recommend a naming convention for object schemas\n   * such as below for ensuring uniqueness:\n   *\n   * - for globally shared objects: The pattern `$field:${KlassName}` e.g. `$field:AddressObject`\n   * - for resource-specific objects: The pattern `$${ResourceKlassName}:$field:${KlassName}` e.g. `$User:$field:ReusableAddress`\n   * - for inline objects: The pattern `$${ResourceKlassName}.${fieldPath}:$field:anonymous` e.g. `$User.shippingAddress:$field:anonymous`\n   *\n   * @typedoc\n   */\n  type: string;\n\n  /**\n   * The fields that make up the shape of the resource\n   *\n   * @typedoc\n   */\n  fields: LegacyModeFieldSchema[];\n\n  /**\n   * A list of traits that this resource implements. The fields for these\n   * traits should still be defined in the fields array.\n   *\n   * Each trait should be a string that matches the `type` of another\n   * resource schema. The trait can be abstract and reference a resource\n   * type that is never defined as a schema.\n   *\n   * @typedoc\n   */\n  traits?: string[];\n}\n\n/**\n * A type which represents a valid JSON schema\n * definition for either a PolarisMode or a\n * LegacyMode resource.\n *\n * Note, this is separate from the type returned\n * by the SchemaService which provides fields as a Map\n * instead of as an Array.\n *\n * @typedoc\n */\nexport type ResourceSchema = PolarisResourceSchema | LegacyResourceSchema;\n\n/**\n * Represents a schema for an object that is not\n * a primary resource (has no unique identity of its own).\n *\n * ObjectSchemas may not currently contain relationships.\n *\n * @typedoc\n */\nexport interface ObjectSchema {\n  /**\n   * Either a HashField from which to calculate an identity or null\n   *\n   * In the case of `null`, the object's identity will be based\n   * on the referential identity of the object in the cache itself\n   * when an identity is needed.\n   *\n   * @typedoc\n   */\n  identity: HashField | null;\n\n  /**\n   * The name of the schema\n   *\n   * The names of object and resource schemas share\n   * a single namespace and must not conflict.\n   *\n   * We recommend a naming convention for object schemas\n   * such as below for ensuring uniqueness:\n   *\n   * - for globally shared objects: The pattern `$field:${KlassName}` e.g. `$field:AddressObject`\n   * - for resource-specific objects: The pattern `$${ResourceKlassName}:$field:${KlassName}` e.g. `$User:$field:ReusableAddress`\n   * - for inline objects: The pattern `$${ResourceKlassName}.${fieldPath}:$field:anonymous` e.g. `$User.shippingAddress:$field:anonymous`\n   *\n   * @typedoc\n   */\n  type: string;\n\n  /**\n   * The fields that make up the shape of the object\n   *\n   * @typedoc\n   */\n  fields: ObjectFieldSchema[];\n}\n\nexport type Schema = ResourceSchema | ObjectSchema;\n\n/**\n * A no-op type utility that enables type-checking resource schema\n * definitions.\n *\n * Will return the passed in schema.\n *\n * This will not validate relationship inverses or related types,\n * as doing so would require a full schema graph to be passed in\n * and no cycles in the graph to be present.\n *\n * @method resourceSchema\n * @static\n * @for @warp-drive/core-types\n * @param {ResourceSchema} schema\n * @returns {ResourceSchema} the passed in schema\n * @public\n */\nexport function resourceSchema<T extends ResourceSchema>(schema: T): T {\n  return schema;\n}\n\n/**\n * A no-op type utility that enables type-checking object schema\n * definitions.\n *\n * Will return the passed in schema.\n *\n * @method objectSchema\n * @static\n * @for @warp-drive/core-types\n * @param {ObjectSchema} schema\n * @returns {ObjectSchema} the passed in schema\n * @public\n */\nexport function objectSchema<T extends ObjectSchema>(schema: T): T {\n  return schema;\n}\n\n/**\n * A type utility to narrow a schema to a ResourceSchema\n *\n * @method isResourceSchema\n * @static\n * @for @warp-drive/core-types\n * @param schema\n * @returns {boolean}\n * @public\n */\nexport function isResourceSchema(schema: ResourceSchema | ObjectSchema): schema is ResourceSchema {\n  return schema?.identity?.kind === '@id';\n}\n\n/**\n * A type utility to narrow a schema to LegacyResourceSchema\n *\n * @method isLegacyResourceSchema\n * @static\n * @for @warp-drive/core-types\n * @param schema\n * @returns {boolean}\n * @public\n */\nexport function isLegacyResourceSchema(schema: ResourceSchema | ObjectSchema): schema is LegacyResourceSchema {\n  return isResourceSchema(schema) && schema.legacy === true;\n}\n\nexport type LegacyField =\n  | LegacyAttributeField\n  | LegacyBelongsToField\n  | LegacyHasManyField\n  | LinksModeBelongsToField\n  | LinksModeHasManyField;\nexport type LegacyRelationshipField =\n  | LegacyBelongsToField\n  | LegacyHasManyField\n  | LinksModeBelongsToField\n  | LinksModeHasManyField;\n"],"names":["resourceSchema","schema","objectSchema","isResourceSchema","identity","kind","isLegacyResourceSchema","legacy"],"mappings":"AAAA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAiCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAyEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAqEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAgFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAsHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAqHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAkHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAwHA;AACA;AACA;AACA;AACA;;AAgBA;AACA;AACA;AACA;AACA;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAmBA;AACA;AACA;AACA;AACA;AACA;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAwDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAwDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAwCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,cAAcA,CAA2BC,MAAS,EAAK;AACrE,EAAA,OAAOA,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,YAAYA,CAAyBD,MAAS,EAAK;AACjE,EAAA,OAAOA,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASE,gBAAgBA,CAACF,MAAqC,EAA4B;AAChG,EAAA,OAAOA,MAAM,EAAEG,QAAQ,EAAEC,IAAI,KAAK,KAAK;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,sBAAsBA,CAACL,MAAqC,EAAkC;EAC5G,OAAOE,gBAAgB,CAACF,MAAM,CAAC,IAAIA,MAAM,CAACM,MAAM,KAAK,IAAI;AAC3D;;;;"}