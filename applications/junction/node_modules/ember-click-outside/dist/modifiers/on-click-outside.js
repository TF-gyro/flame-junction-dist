import { next, cancel } from '@ember/runloop';
import { registerDestructor } from '@ember/destroyable';
import Modifier from 'ember-modifier';

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

// https://github.com/zeppelin/ember-click-outside/issues/23

const proto = typeof Element !== 'undefined' ? Element.prototype : {};
const vendor = proto.matches || proto.matchesSelector || proto.webkitMatchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector;
function matches(el, selector) {
  if (!el || el.nodeType !== 1) return false;
  if (vendor) return vendor.call(el, selector);
  var nodes = el.parentNode.querySelectorAll(selector);
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i] == el) return true;
  }
  return false;
}

function closest(element, selector) {
  if (matches(element, selector)) {
    return element;
  }
  while (element.parentNode) {
    element = element.parentNode;
    if (matches(element, selector)) {
      return element;
    }
  }
}
const documentOrBodyContains = element => {
  // https://github.com/zeppelin/ember-click-outside/issues/30
  if (typeof document.contains === 'function') {
    return document.contains(element);
  } else {
    return document.body.contains(element);
  }
};
const ios = () => {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
};

class ClickOutsideModifier extends Modifier {
  constructor() {
    super(...arguments);
    _defineProperty(this, "didSetup", false);
    _defineProperty(this, "action", null);
    _defineProperty(this, "capture", null);
    _defineProperty(this, "eventHandler", null);
    _defineProperty(this, "eventType", 'click');
    _defineProperty(this, "exceptSelector", null);
    _defineProperty(this, "cancelOutsideListenerSetup", null);
    _defineProperty(this, "cleanup", () => {
      this._destroy();
      if (ios()) {
        document.body.style.cursor = '';
      }
    });
    registerDestructor(this, this.cleanup);
  }
  modify(element, [action], {
    capture,
    eventType,
    exceptSelector
  }) {
    if (!this.didSetup) {
      if (ios()) {
        document.body.style.cursor = 'pointer';
      }
      this.didSetup = true;
    } else {
      this._destroy();
    }
    this._init({
      element,
      action,
      capture,
      eventType,
      exceptSelector
    });
  }
  _init({
    element,
    action,
    capture,
    eventType,
    exceptSelector
  }) {
    if (!action) {
      return;
    }
    this.action = action;
    this.exceptSelector = exceptSelector;
    this.capture = capture;
    if (eventType) {
      this.eventType = eventType;
    }
    this.eventHandler = this._createHandler(element, this.action, this.exceptSelector);
    this.cancelOutsideListenerSetup = next(this, this._addClickOutsideListener);
  }
  _destroy() {
    if (!this.action) {
      return;
    }
    cancel(this.cancelOutsideListenerSetup);
    this._removeClickOutsideListener();
  }
  _addClickOutsideListener() {
    let {
      capture,
      eventHandler,
      eventType
    } = this;
    document.addEventListener(eventType, eventHandler, {
      capture
    });
  }
  _removeClickOutsideListener() {
    let {
      capture,
      eventHandler,
      eventType
    } = this;
    document.removeEventListener(eventType, eventHandler, {
      capture
    });
  }
  _createHandler(element, action, exceptSelector) {
    return e => {
      if (exceptSelector && e.target && closest(e.target, exceptSelector)) {
        return;
      }
      let path = e.path || e.composedPath && e.composedPath();
      if (path) {
        path.includes(element) || action(e);
      } else {
        // Check if the click target still is in the DOM.
        // If not, there is no way to know if it was inside the element or not.
        let isRemoved = !e.target || !documentOrBodyContains(e.target);

        // Check the element is found as a parent of the click target.
        let isInside = element === e.target || element.contains(e.target);
        if (!isRemoved && !isInside) {
          action(e);
        }
      }
    };
  }
}

export { ClickOutsideModifier as default };
//# sourceMappingURL=on-click-outside.js.map
